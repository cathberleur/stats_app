---
title: "Travail sur sous-bases d'1 type de délinquance"
author: "Bracq, Meyer"
date: "2023-01-25"
header-includes:
- \usepackage{fancyhdr}
- \pagestyle{fancy}
- \fancyhead{}
- \fancyfoot{}
- \fancyhead[CO,CE]{Poing Levé}
- \fancyfoot[CO,CE]{Sondage}
- \fancyfoot[R]{\thepage}
output:
  pdf_document:
    toc: yes
    toc_depth : 3
    latex_engine: xelatex
  html_document:
    toc: yes
editor_options: 
  markdown: 
    wrap: sentence
---

```{=html}
<style>
body {
text-align: justify}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

```

```{r, include=FALSE}
list.of.packages <- c("tidyverse", "haven", "readxl", "stats", "ggplot2", "ggcorrplot", "data.table", "dplyr", "corrplot", "stargazer", "Hmisc",'cartography','sf','rgdal','sp')
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos = "http://cran.us.r-project.org")

invisible(lapply(list.of.packages, library, character.only = TRUE))

setwd("~/Documents/ENSAE/Stats_app")
```


```{r, charger-libraries}
library(sf)
library(rgdal)
library(cartography)
library(sp)
library(dplyr)
library(tibble)
library(data.table)
library(reshape2)
library(tidyr)
```

Le but étant d'alléger la base, penser à nettoyer le "global environment" avant de charger une sous-base. A exécuter après la feuille mise_en_forme_donnees (ou changer le lien de chargement des fichiers si ils sont enregistrés ailleurs pour ne pas les recréer inutilement à chaque fois)

```{r, chargement-d-une-sous-base}
t.del.A <- readRDS("~/GitHub/stats_app/del_merged_A.rds")
#t.del.A <- readRDS("C:\\Users\\marie\\OneDrive\\Documents\\cours\\ensae\\stat app\\sous df\\del_merged_A.rds")
t.del.O <- readRDS("~/GitHub/stats_app/del_merged_O.rds")
t.del.K <- readRDS("~/GitHub/stats_app/del_merged_K.rds")

```

```{r zonages-chr-to-num}

liste_zonages <- colnames(t.del.O)[14:26]
t.del.O[,liste_zonages] <- sapply(t.del.O[,liste_zonages], as.numeric)

```

on cherche quels zonages permettent au mieux de regrouper les trois adresses d'une observation :
idée : (pas sûre que ce soit la manière la + ergonomique de faire)
pour cela, on veut créer une indicatrice qui indique si les 3 communes appartiennent au même zonage ou non, pour chaque zonage
(on fait ensuite la somme pour avoir l'effectif / proportion --> /3 car on a triplé les lignes en passant au format long)

idem avec 2 communes --> il faut faire infraction + mec et infraction + victime et? victime + mec ? (est-ce que toutes ces infos sont pertinentes ??)

l'idéal est d'avoir une fonction qui prend en argument la sous-base pour qu'on puisse faire la même chose pour tous les types de délinquance, mais on commence sans fonction sur la sous-base O(la moins lourde)

#METHODE 2
```{r essai}

# t.del.O <- t.del.O %>% select(-'indicEPCI')

df_O_groupby <- group_by(t.del.O, t.del.O$id)# group_by selon l'id
df_O_groupby$EPCI <- as.numeric(df_O_groupby$EPCI) # zonage en num (il faut tous les changer après)
df_O_groupby <- mutate(df_O_groupby, liste_commune=sum(EPCI)) 
# dans liste_commune : somme des 3 zonages EPCI si les 3 communes sont renseignées, NA si une commune manquante

#df_O_groupby_test <- mutate(df_O_groupby_test, indicEPCI = sum(case_when(
#    ((df_O_groupby_test$liste_commune/3)==df_O_groupby_test$EPCI) ~ 1,
#     ((df_O_groupby_test$liste_commune/3)!=df_O_groupby_test$EPCI) ~ 0
#    ))) # très long aussi :(
# on peut comparer la somme/3 à EPCI des 3, si c'est égal alors on a le même sur les 3 --> indic = 1, sinon ils sont différents --> indic=0:

df_O <- ungroup(df_O_groupby)
df_O <- mutate(df_O, indicEPCI = case_when(
    ((df_O$liste_commune/3)==df_O$EPCI) ~ 1,
     ((df_O$liste_commune/3)!=df_O$EPCI) ~ 0
    ))
# dans indicEPCI, 1 si les 3 appartiennent au même zonage EPCI, 0 sinon

df_O$indicEPCI[is.na(df_O$indicEPCI)] <- 0 #remplace na par 0, ok car on fait la somme
sum(df_O$indicEPCI)
sum(df_O$indicEPCI)/3 # nombre d'obs pour lesquelles les 3 communes sont dans le même zonage EPCI
# pourquoi pas un nombre entier ?
# [1] 7437.333



```

```{r essai-avec-autre-zonage}

df_O_groupby$AAV2020 <- as.numeric(df_O_groupby$AAV2020) # zonage en num (il faut tous les changer après)
df_O_groupby <- mutate(df_O_groupby, liste_commune=sum(AAV2020)) 

df_O <- ungroup(df_O_groupby)
df_O <- mutate(df_O, indicAAV2020 = case_when(
    ((df_O$liste_commune/3)==df_O$AAV2020) ~ 1,
     ((df_O$liste_commune/3)!=df_O$AAV2020) ~ 0
    ))
# dans indicEPCI, 1 si les 3 appartiennent au même zonage EPCI, 0 sinon

df_O$indicAAV2020[is.na(df_O$indicAAV2020)] <- 0 #remplace na par 0, ok car on fait la somme
sum(df_O$indicAAV2020)
sum(df_O$indicAAV2020)/3 # nombre d'obs pour lesquelles les 3 communes sont dans le même zonage EPCI

#[1] 9198

# pas même résultats :(
```

#METHODE 1

Autre idée : pour un zonage donné, boucle sur les id (distincts) --> +1 si les 3 lignes correspondant au même id sont le même zonage --> on obtient l'effectif des infractions où les 3 communes sont dans le même zonage
--> prend beaucoup de temps :(
à transformer en fonction selon zonage après
voir surtout si ça ne prend pas trop de temps à tourner ...
```{r methode-1}
unique_id <- unique(t.del.O$id)

proportion_zonages <- function(type_zonage) {
  effectif = 0
  for (idf in unique_id){
    if (is.na(t.del.O[t.del.O$id == idf,type_zonage][1,]) | is.na(t.del.O[t.del.O$id == idf,type_zonage][2,]) | is.na(t.del.O[t.del.O$id == idf,type_zonage][3,])) effectif = effectif #cas où les 3 communes ne sont pas renseignées
    else if (((t.del.O[t.del.O$id == idf,type_zonage][1,]) == (t.del.O[t.del.O$id == idf,type_zonage][2,])) & ((t.del.O[t.del.O$id == idf,type_zonage][1,] == t.del.O[t.del.O$id == idf,type_zonage][3,])))  effectif = effectif+1
    # si les 3 communes sont les mêmes, on incrémente 
  }
  cat(type_zonage,' : ',effectif,' (',(effectif/length(unique_id))*100,'%)\n')
}

liste_zonages <- colnames(t.del.O)[14:26] # on récupère une liste de tous les types de zonages (colonne arrondissement à la fin)
lapply(liste_zonages, proportion_zonages) # 19h17 à 20h22
# CV  :  2633
# EPCI  :  7433
# NATURE_EPCI  :  10255
# ZE2020  :  9796
# UU2020  :  7320
# TUU2017  :  7945
# TDUU2017  :  7742
# AAV2020  :  11863
# TAAV2017  :  12284
# TDAAV2017  :  11958
# CATEAAV2020  :  7336
# BV2012  :  9692



effectif_EPCI = 0
effectif_EPCI #7433
proportion_EPCI <- effectif_EPCI / length(unique_id)
proportion_EPCI #0.1523

```

#METHODE 3
après discussion avec Aurélien, on retente de repasser le format long en wide après les jointures
```{r methode-3}

liste_classe
t.del.O['info commune'] <- as.character(t.del.O['info commune']) 


# t.del.O <- t.del.O %>% select(-'indicEPCI')
df_O <- as.data.frame(t.del.O)

df_O_wide <- pivot_wider(data=t.del.O, names_from = 'info commune', id_cols = 'id', values_from = 'EPCI')

df_O_wide['indic_EPCI'] <- case_when(
  ((df_O_wide$cog_com_22_mec == df_O_wide$cog_com_22_vict) & ( df_O_wide$cog_com_22_mec == df_O_wide$cog_com_22_inf)) ~ 1,
  TRUE ~ 0)

unique_id <- unique(t.del.O$id)
sum(df_O_wide$indic_EPCI)
sum(df_O_wide$indic_EPCI)/length(unique_id)
# 7433, 0.1523

```

```{r essai-AAV2020}


df_O_wide_AAV2020 <- pivot_wider(data=t.del.O, names_from = 'info commune', id_cols = 'id', values_from = 'AAV2020')

df_O_wide_AAV2020['indic_AAV2020'] <- case_when(
  ((df_O_wide_AAV2020$cog_com_22_mec == df_O_wide_AAV2020$cog_com_22_vict) & ( df_O_wide_AAV2020$cog_com_22_mec == df_O_wide_AAV2020$cog_com_22_inf)) ~ 1,
  TRUE ~ 0)

sum(df_O_wide_AAV2020$indic_AAV2020)
sum(df_O_wide_AAV2020$indic_AAV2020)/length(unique_id)
# 11863, 0.2430694


```

transformer méthode 3 en fonction
```{r fonction-effectifs}
liste_classe <- unique(t.del$classe) # on récupère une liste de toutes les classes de délinquance


t.del.O['info commune'] <- as.character(t.del.O['info commune']) 
t.del.A['info commune'] <- as.character(t.del.A['info commune']) 
t.del.K['info commune'] <- as.character(t.del.K['info commune']) 

d <- c(t.del.O, t.del.A, t.del.K)
d <- lapply(d, as.data.frame)
df_O <- as.data.frame(t.del.O)



df_O_wide <- pivot_wider(data=t.del.O, names_from = 'info commune', id_cols = 'id', values_from = 'EPCI')

df_O_wide['indic_EPCI'] <- case_when(
  ((df_O_wide$cog_com_22_mec == df_O_wide$cog_com_22_vict) & ( df_O_wide$cog_com_22_mec == df_O_wide$cog_com_22_inf)) ~ 1,
  TRUE ~ 0)

unique_id <- unique(t.del.O$id)
sum(df_O_wide$indic_EPCI)
sum(df_O_wide$indic_EPCI)/length(unique_id)
# 7433, 0.1523



'''```{r}
df
unique_id <- unique(df_1619$id)
for (idf in unique_id){
  if df_1619$cog_com_22_inf == df_1619$cog_com_22_vict
  '''
  

```


```


